---
layout: post
title: Handler、Looper与线程
date: 2017-06-12
categories: blog
tags: [编程]
description: 无
---

# Handler、Looper与线程

面试的时候呢，这个Handler机制总是无法逃避的话题，虽然之前也看过很多资料，但今天还是好好总结一下，方便以后回顾。

### 起因

首先我们在研究一个东西的时候呢，首先得了解它出现的背景。

平时我们在编写java控制台程序的时候呢，一般都是写一个类，然后在main函数中去做一系列的处理。

那么也就是说`main()`是**程序的入口**。

那么对于GUI程序来说，会是怎样的呢？其实JVM也是从一个类的main函数去启动的，但可能平台本身将这种行为隐藏了起来，让我们更加专注于编写程序逻辑（业务逻辑）。

```java
public static void main(){
  1.准备工作（资源准备、启动服务）
  2.进入事件循环处理
}
```

在Android里面，我们开发者一般都是面对着四大组件去进行编程，而不会像控制台程序一样，还得写一堆模板代码。但是在Android中，可以说一个APP的起点就是从`ActivityThread.main()`开始的，然后系统会帮我们处理很多事情（比如说准备和AMS的交互），最后会启动我们在配置文件中指定的Activity。

如果是普通的控制台程序，运行完一段逻辑就会自动退出了；但是对于GUI程序，不可能莫名其妙就消失吧？所以要怎样才能让它不退出呢？OK，循环可以解决这个问题，但我们怎么利用循环来响应用户操作或者其他的呢？

那么“串行事件处理”就这样产生了，主线程可以采取依次处理的方式（一个处理完了才能处理下一个）。

将所有需要处理的事件组织为一个队列，然后主线程每次通过循环从队列的最前面取出事件进行对应的处理。

用伪代码表示一下：

```
while(true){
  Message msg = queue.get(); //得到最前面的事件
  //根据不同种类的事件，进行对应处理工作
  switch(msg.code){
    case 01:xxxx;break;
    ....
  }
}
```

所以handler、Looper和MessageQueue这一套体系其实就是"串行事件处理"模型的实现。

在这个模型当中，有这么几个概念：

- 消息队列（MessageQueue）：组织一个消息队列
- 消息循环（Looper所在的线程）：不断从消息队列中取出消息，然后交给消息处理者进行处理
- 消息处理者（handler）：具体地去处理消息

> 这里省略了GUI是单线程，具体可以参见《Java并发编程实战》

同时呢，因为GUI是单线程的，所以它们一般使用了线程封闭机制（子线程不能更新UI），这个Handler这时候又起到第二个功效：线程的切换。例如我们在子线程进行了数据库访问，然后通过handler对UI进行数据更新。

### 相互之间数量关系

前面讲了"串行事件处理"模型，其实这也不是Android首创的，早在Swing中就有对应的实现了。

在Android中，是怎么组织的呢？首先借用一张图：  [来源](https://www.youtube.com/watch?v=aV2XfWwpiDU)

![mark](http://oicc5e0b7.bkt.clouddn.com/blog/20170611/222537285.png)

这里我也不想去深究Looper、handler、MQ和Message的实现细节了，源代码和网上的资料很多都可以说清楚了。

我想用比喻去把这样的机制说清楚（虽然好像更复杂了，主要是懒得画图）：

- Looper（工厂）
- Thread（工厂老板）
- Handler（工厂工人）
- Message（待加工商品）
- MessageQueue（流水线）
- CPU时间（钱）

在Android的世界里，可能需要一些设定，因为这些比喻可能和平时不太一样：

1. 一个工厂老板最多只能拥有一个工厂
2. 一般情况下，工厂老板不知道其他老板旗下工厂的名字
3. 一个工厂只有一条流水线，且这个流水线上每个时刻都允许一个工人干活
4. 工厂会不断地取出最先进入流水线的待加工商品，交给工人处理
5. 一个工厂可以有多个工人，但每个工人都必须依托于一个工厂才能干活
6. 其实这些待加工商品只是工人自己弄出来的把戏，他们只是想赚钱而已。所以哪位工人制造出来的商品，就由哪位工人进行加工（自己收取加工费）
7. 一旦某个工厂的名字被曝光了，那么它的流水线就暴露了，那么其他老板就可以安插自己的工人去赚其他工厂的钱

具体对应Android的原理：

1、ThreadLocal保证每个Thread最多只能有一个Looper，而且一旦Thread创建了Looper，那么这个线程就变成了Looper线程，无限轮询去取消息队列中的消息；

2、同样是ThreadLocal保证了Thread之间是无法直接看到对方的Looper的，但也有其他的方法，比如说可以将主线程的Looper用引用保存起来，然后子线程需要使用的时候就可以通过`getMainLooper()`来获取；

3、每个Looper都有一个消息队列MessageQueue，这个消息队列是在堆上的（可以在不同线程间共享）；

4、既然是消息队列，队列就讲究一个先进先出；

5、每个handler必须有一个消息队列才能去发送消息，而消息队列又是属于Looper的，所以Handler的创建必须要有Looper的存在；但一个线程可以同时有多个Handler，比如主线程就有垂直同步的handler、控制生命周期的handler还有键盘输入的handler；

6、Message必须通过Handler去post，同时就会把Message.target设置为这个Handler，然后通过我们重写Handler的dispatchMessage方法去做相应的逻辑处理；

7、`getMainLooper()`可以获取主线程的Looper，我们可以在子线程中去创建Handler，但Handler的dispatchMessage则是在主线程中执行。

**后面如果有空的话，会试着完善这套理论，并且画图出来**