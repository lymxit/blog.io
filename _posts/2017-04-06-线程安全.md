---
layout: post
title: 线程安全
date: 2017-04-06
categories: blog
tags: [编程]
description: 无
---

# 线程安全

#### 线程安全的实现方法

1、互斥同步（阻塞同步）：互斥是方法，同步是目的。

​      互斥实现的几种方式：临界区、互斥量、信号量。

​       synchronized:可重入，jdk1.6有优化。ReentrantLock:增加了高级功能（等待可中断、可实现公平锁、条件锁）

​     **等待可中断：**当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情。

​     **公平锁：**多个线程在等待同一个锁时，必须按照申请锁的时间顺序依次获取锁，而非公平锁（默认）并不会保证这一点。

​     **条件锁：**一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，只能实现一个隐含的条件。

2、非阻塞同步：随着硬件指令集的发展，可以实现基于**冲突检测**的乐观并发策略。

原子性指令 （新增）：CAS(比较并交换)、LL/SC(加载链接/条件存储)。

**CAS**：需要有3个操作数，内存地址（V）、旧的估计值（A）和新值（B）。CAS执行时，当且仅当V符合旧预期值A时，才会用B去更新V的值。在`ConcurrentHashmap`中使用了`UnSafe`类来完成CAS操作。

#### 无同步方案

**可重入代码**：一个方法，只要输入相同的参数，返回的结果一定是同样地，那么就是线程安全的。

**线程本地存储：**如果一个对象仅被一个线程观察并持有，那么肯定是线程安全的，ThreadLocal对象就可以实现这这样的功能，`Looper`就是这样保证每个线程最多有一个`Looper`对象。

### 锁优化

#### 自旋锁与自适应锁

由于java线程的底层实现，互斥同步的性能瓶颈就在于阻塞的实现（挂起线程和恢复线程需要切换到内核态）。

如果机器有一个以上的CPU，能让两个及以上的线程并行执行，那么可以让后面那个请求锁的线程"稍等一下"，而不放弃CPU的执行时间，而是执行一个忙循环（自旋）。

自旋等待虽然避免了线程切换的开销，但是还是会白白占用CPU的资源，，如果自旋时间很长，在性能上就有很大的浪费。

**自适应：**自旋的时间不再固定，由前一次在同一个锁上自旋时间及锁的拥有者的状态来决定。（如果前面成功获取，自旋次数会变多；获取成功次数较少，则可能省略自旋过程）

#### 锁消除

如果对于一些同步块的代码，虚拟机检测到不可能存在共享数据竞争，那么就会消除这个同步块的锁来提高性能。

#### 锁粗化

一般在编程的时候，会尽量把同步块的范围限制的很小，但是如果对于同一个锁反复进行，就会出现性能上的巨大损耗。

```java
Object lock = new Object();
... //省略方法签名
int sum = 0;
for(int i = 0 ;i < 100;i++)
  synchronized(lock){
    sum += i;
  }
//粗化之后可能变成
synchronized(lock ){
  for循环...
}
```

#### 轻量级锁

在HotSpot虚拟机中，每个对象都有对象头，第一部分叫做"Mark Word"，如果在32位的虚拟机中，"Mark Word"也是32位的， **未锁定**状态下，25bit存HashCode，4bit寸分代年龄，**2bit存锁标记位**，1bit固定0。

下面是不同状态下"Mark Word"的存储情况：

| 存储内容                | 标志位  | 状态        |
| ------------------- | ---- | --------- |
| 对象哈希码、对象分代年龄        | 01   | 未锁定       |
| 指向锁记录的指针            | 00   | 轻量级锁定     |
| 指向重量级锁的指针           | 10   | 膨胀（重量级锁定） |
| 空                   | 11   | GC标记      |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01   | 可偏向       |

在进入同步块时，如果标志位是"01"。

虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存放锁对象目前"Mask Word"的拷贝。

然后，虚拟机将使用CAS操作**尝试**将对象的Mask Word更新为指向锁记录的指针。如果更新成功，那么线程就拥有了该对象的锁，且Mask Word的锁标志为更新为"00"（轻量级锁定）。那更新失败怎么办呢？虚拟机会检查锁对象的Mask Word是否指向当前线程的栈帧，如果是，说明当前线程已经持有该对象的锁了，否则就膨胀为重量级锁，锁标志为"10"，后续等待锁的线程也要进入阻塞状态。

![mark](http://oicc5e0b7.bkt.clouddn.com/blog/20170408/161803759.png)

释放锁也是通过CAS操作完成的，如果Mask Word任然指向线程的锁记录（说明持有锁），那就用CAS操作把对象的Mask Word和线程中的锁记录替换回来（复原hashcode、分代年龄）。替换成功则说明同步完成，替换失败（也就是锁标志位为10），说明这是一个重量级锁，需要唤醒这个锁对象上挂起的其他线程。

如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在竞争，轻量级锁比重量级锁额外进行了CAS操作。

#### 偏向锁

目的：消除数据在无竞争情况下的同步原语，提高程序运行性能。

相比于轻量级锁，偏向锁在后续的同步中连CAS操作都不做了。

对象锁会偏向于第一个获得它的线程，如果在接下来的执行过程中没有发生竞争，那么持有偏向锁的线程永远不用进行同步。

当另外一线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象是否被锁定的状态，恢复到未锁定或者轻量级锁的状态。