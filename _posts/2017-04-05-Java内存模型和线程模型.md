---
layout: post
title: Java内存模型和线程模型
date: 2017-04-05
categories: blog
tags: [编程]
description: 无
---

# Java内存模型

《深入理解java虚拟机》读书笔记

### 主内存和工作内存

在多处理器系统中，每个处理器都有自己的高速缓存；类似于处理器高速缓存，每个Java线程都对应一个工作内存。

![mark](http://oicc5e0b7.bkt.clouddn.com/blog/20170407/162829274.png)

线程不能直接读写主内存的变量，而只能通过工作内存去操作，所以不同线程其实也是无法直接互相访问的。

### 内存间互相操作

- lock:线程独占某个主内存的变量
- unlock
- read:将一个变量的值从主内存传输到工作内存中
- load:把read操作获取的值在工作内存中创建一个副本（copy）
- use:把工作内存中的一个变量的值传递给执行引擎
- assign:将从执行引擎中获取的值赋给工作内存的变量
- store:将工作内存中一个变量的值传送给主内存中，方便write调用
- write:将store操作从工作内存中得到的变量的值放入主内存的变量中

一般read和load是配套的，store和write也是配套的。



![mark](http://oicc5e0b7.bkt.clouddn.com/blog/20170407/170751167.png)

![mark](http://oicc5e0b7.bkt.clouddn.com/blog/20170407/171226540.png)



### volatile的特殊规则

**特点1**：volatile在每个线程的工作内存中不存在不一致问题（即保证了对线程的可见性），每次使用volatile时都会去从主内存中save/load该变量。

但是能说volatile保证了变量一定是原子操作吗？并不一定

比如说:

```java
public static volatile int count = 0;
public static void increase(){count++;} //10个线程都调用一次	
```

结果会是10吗？结果是不确定的：count++看上去只有一行，但实际是3个操作的组合：

1. 从主内存中取出这个变量的值（这个保证是最新的）
2. 用将这个变量+1
3. 将+1的结果重新赋值给变量（同步回主内存）

volatile只能保证第1步是正常进行的，比如说`Thread 1`获得了0，然后在Step 2的时候`Thread 2`去获取count的值，当然也只能获取到0了，当`Thread 1`结束第三步的时候把主内存中的count设置为1了。然后`Thread 2`又将主内存的count设置为1。这就是为什么结果不准确的原因（真实情况下更复杂）。

![mark](http://oicc5e0b7.bkt.clouddn.com/blog/20170407/234124751.png)

**特点2：**禁止指令重排序优化。这里就要提到一个"Happends-Before"原则了，这个规则有点复杂，在国人一本《并发》有很好的阐述。

大概介绍一下，就是这样的：

```java
int a = 0;
int b = 233;
a += 50;  //step 1
b += 80;  //step 2
System.out.println(b);  //step 3
```

step 1和step 2中没有任何依赖的关系（也就是相互独立的），那么真正在执行的时候，step 2可能在step 1之前执行。但step 3对b变量有依赖，所以step 3肯定是在step 2之后完成的。

那如果加了volatile会怎样呢？

```java
int a = 0;
volatile int b = 233;
a += 50;  //step 1
b += 80;  //step 2
System.out.println(b);  //step 3
```

那么顺序一定是step1 -> step2 -> step3，因为volatile禁止了指令的重排序（通过内存屏障）。

#### volatile的优缺点：

在某种情况上可以作为无锁编程的方式（运算结果并不依赖变量的当前值，或者只有单一的线程写值），在性能上比synchronized和lock好一些。

在读取方面的性能和普通变量差不多，但在写操作上会慢一些（因为加入了内存屏障来禁止重排序，而重排序可以看做是对程序的优化）。

### 对于long和double型变量的注意事项

由于long和double是64位的，而之前内存操作的8个操作只保证了32位的原子性。

因为JMM规定了：**允许**虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。

如果不知道虚拟机具体的实现，稳重起见可以使用对应的原子类。

#### volatile、synchronized和final对于可见性的影响

- volatile：保证了修改的新值能够立刻同步到主内存，而且在使用前会从主内存中刷新变量的值。
- synchronized：从字节码层面是通过monitorenter和monitorexit去实现的，而这两个指令底层实现还是通过lock和unlock，所以在退出同步块的时候（unlock），会把同步块中的所有变量同步回主内存中。
- final：被final修饰的字段在构造器中一旦初始化完成，并且构造器并没有把"this"逸出去，那么就可以无需同步被多线程访问。

在构造器没有完成之前，"this"引用逃逸非常危险，可能你初始化了一半的数据，还有另外一半数据是null或者初始值，那么这时候通过"this"去调用一些用到无效数据的方法就会出现问题。

## Java线程

### 线程

#### 概念：轻量级进程，把进程的资源分配和执行调度分开，CPU调度的基本单位

#### 实现方式：与平台相关

**1、内核线程**

每个轻量级进程都对应一个内核进程，是一个独立的调度单元，即使有一个在系统调用中阻塞了，也不会影响整个进程工作。

局限性：基于内核线程实现，线程操作都需要系统调用（代价高，需要切换用户态和内核态）。

​	        而且每个轻量级进程都需要消耗一定的内核资源（如内核线程的栈空间），系统资源有限。

**2、用户线程**

狭义上的用户线程操作完全在用户态完成，不需要内核帮助。但是实现起来比较复杂。Java弃用。

**3、用户线程+轻量级线程混合**

用户线程：轻量级进程 是N：M的关系，轻量级进程和内核线程依旧是一一对应。

**4、Java线程实现**

对于Sun JDK来说，在Windows和Linux下是通过一对一的线程模型（轻量级进程）实现的。

### Java线程调度

**1、协同式线程调度：**线程的执行时间由线程本身控制，线程执行完之后要主动通知操作系统切换线程。

**2、抢占式线程调度（Java采用）：**线程的执行时间由系统分配，线程的切换也不由线程本身决定（虽然有Thread.yeild()可以让出时间，但没有对应可以得到时间的api）。

#### Java中的线程状态

- 新建：没有调用start()

- 运行：包括了操作系统线程状态中的Running和Ready，可能在执行，也可能在等CPU分配

- 无限期等待:调用了Object.wait()、Thread.join()、LockSupport.park()

- 有限期等待：sleep()、有超时参数的wait()和join()

- 阻塞：synchronized，在等待获取一个排他锁。

- 结束

  ​